
Potential strategies:
1. Materialized Chunk identity + index.
   Merge the elements into chunks, and hash those chunks
   in a merkle tree,then element identity chunk + index
2. Hashfusion
   Identify a cryptographically secure hashing algorithm which allows for associative
   merging such that the identity of any fragmentary agglomeration is the same as its materialized version
   https://www.labs.hpe.com/techreports/2017/HPE-2017-08.pdf
3. MaxFrag Merkel Tree
   For any given fragmentary agglomeration, build a merkel tree based on the maximum fragmentation
   In so doing, every agglomerated representation which projects the same output posesses
   the same identity. This is much less efficient than Hashfusion, but is imminently more implementable
   and much more likely to be cryptographically sound
QUESTIONs:
1. how do HashFusion and MaxFrag approaches work with hidden/erased information? and how do they differ?
2. does every erasure require a materialization and breaking of the concatenative identity?
3. materialized hashing vs "lineage" hashing
   (I thinkk the former can only apply to materializations which are themselves CRDTs, rather than the CRDT being embodied in the lineage)
   A text body fragmented arbitrarily, and edited by a single editor lacks "Hidden" state.
   A set being edited concurrently may not have arbitrarily fragmented operations which hash identically with the materialization
      *however* a lineage preserving hash may?

4. How does this apply to unbase indexes?
You will still need to order concurrencies for the hashing process, but not necessarily all at the same time
TASKS:
1. Implement the MaxFrag Merkel tree approach (explode every document fragment into a character tree)
2. Implement rust version of Hashfusion algo
3. Study potential preimage attacks